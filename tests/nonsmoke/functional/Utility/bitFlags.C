#include <BitFlags.h>
#include <Sawyer/Assert.h>

enum GlobalFlag { G0=1, G1=2, G2=4, G3=8, G4=16, G5=32 };

// These two functions would normally be generated by ROSE's stringification system if their
// definitions appears somewhere in the ROSE source code. Since this test case isn't part of
// the ROSE source code, they must be implemented by hand.
const std::vector<int64_t> globalFlagValues() {
    static const long values[] = {1, 2, 4, 8, 16, 32};
    static const std::vector<int64_t> vector(values, values+6);
    return vector;
}

const char* globalFlagNames(int64_t value) {
    switch (value) {
        case 1: return "G0";
        case 2: return "G1";
        case 4: return "G2";
        case 8: return "G3";
        case 16: return "G4";
        case 32: return "G5";
        default: return NULL;
    }
}

namespace NameSpace {

enum Flag { NS0=1, NS1=2, NS2=4, NS3=8, NS4=16, NS5=32 };

} // namespace

using namespace Rose;

// Bit flag used as a data member
struct C {
    BitFlags<GlobalFlag> foo;
    BitFlags<NameSpace::Flag> bar;
    C(): bar(NameSpace::NS0) {}
};

// Bit flags used as function arg and return
static BitFlags<GlobalFlag> test01(BitFlags<GlobalFlag> arg = BitFlags<GlobalFlag>()) {
    C c;

    // Default constructor
    ASSERT_always_require(c.foo.vector() == 0);

    // 1-arg constructor
    ASSERT_always_require(c.bar.vector() == NameSpace::NS0);

    // assignment of an enum
    arg = G0;
    ASSERT_always_require(arg.vector() == G0);

    // assignment of multiple enums
    arg = G1 | G2;
    ASSERT_always_require(arg.vector() == (G1 | G2));

    // assignment of one bit vector to another
    c.foo = arg;
    ASSERT_always_require(c.foo.vector() == arg.vector());

    // setting multiple bits
    arg.set(G3).set(G4);
    ASSERT_always_require(arg.vector() == (G1|G2|G3|G4));

    // clearing multiple bits
    arg.clear(G1).clear(G2);
    ASSERT_always_require(arg.vector() == (G3|G4));

    // clearing all bits
    arg = 0;
    ASSERT_always_require(arg.vector() == 0);

    // testing a bit
    arg = G1 | G3;
    ASSERT_always_require(arg.isSet(G1));
    ASSERT_always_require(!arg.isSet(G0));
    ASSERT_always_require(!arg.isClear(G1));
    ASSERT_always_require(arg.isClear(G0));

    // To string
    std::string s = arg.toString(globalFlagValues(), globalFlagNames);
    ASSERT_always_require2(s == "G1|G3", "s=\"" + s + "\"");
    arg = 0;
    s = arg.toString(globalFlagValues(), globalFlagNames);
    ASSERT_always_require2(s == "0", "s=\"" + s + "\"");


    return arg;
}

int main() {
    test01();
}
