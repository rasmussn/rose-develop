/*************************************************************
 * Copyright: (C) 2012 Markus Schordan                       *
 * Author   : Markus Schordan                                *
 * License  : see file LICENSE in the CodeThorn distribution *
 *************************************************************/

//#define ALTERNATIVE_LOCAL_EDGE_HANDLING

#include "sage3basic.h"

#include "CFAnalysis.h"
#include "Labeler.h"
#include "AstTerm.h"
#include <boost/foreach.hpp>
#include "CodeThornException.h"

using namespace CodeThorn;
using namespace std;
using namespace Sawyer::Message;

CFAnalysis::FunctionResolutionMode CFAnalysis::functionResolutionMode=CFAnalysis::FRM_TRANSLATION_UNIT;

Sawyer::Message::Facility CFAnalysis::logger;
void CFAnalysis::initDiagnostics() {
  static bool initialized = false;
  if (!initialized) {
    initialized = true;
    logger = Sawyer::Message::Facility("CodeThorn::CFAnalysis", Rose::Diagnostics::destination);
    Rose::Diagnostics::mfacilities.insertAndAdjust(logger);
  }
}

CFAnalysis::CFAnalysis(Labeler* l):labeler(l),_createLocalEdge(false){
  initDiagnostics();
}
CFAnalysis::CFAnalysis(Labeler* l, bool createLocalEdge):labeler(l),_createLocalEdge(createLocalEdge){
  initDiagnostics();
}
void CFAnalysis::setCreateLocalEdge(bool createLocalEdge) {
  _createLocalEdge=createLocalEdge;
}
bool CFAnalysis::getCreateLocalEdge() {
  return _createLocalEdge;
}
size_t CFAnalysis::deleteFunctionCallLocalEdges(Flow& flow) {
  cerr<<"Internal error: deleteFunctionCallLocalEdges called."<<endl;
  ROSE_ASSERT(false);
  // TODO: investigate why this is not deleting edges
  return flow.deleteEdges(EDGE_LOCAL);
}

// MS: TODO: refactor thse two functions  (1/2)
LabelSet CFAnalysis::functionCallLabels(Flow& flow) {
  LabelSet resultSet;
  LabelSet nodeLabels;
#ifdef ALTERNATIVE_LOCAL_EDGE_HANDLING
  nodeLabels=flow.nodeLabels();
  for(LabelSet::iterator i=nodeLabels.begin();i!=nodeLabels.end();++i) {
    if(labeler->isFunctionCallLabel(*i))
      resultSet.insert(*i);
  }
#else
  // workaround: iterate over all labels to find also non-connected call nodes
  for(Labeler::iterator i=getLabeler()->begin();i!=getLabeler()->end();++i) {
    if(labeler->isFunctionCallLabel(*i))
      resultSet.insert(*i);
  }
#endif

  return resultSet;
}

// MS: TODO: refactor thse two functions  (2/2)
LabelSet CFAnalysis::conditionLabels(Flow& flow) {
  LabelSet resultSet;
  LabelSet nodeLabels;
  nodeLabels=flow.nodeLabels();
  for(LabelSet::iterator i=nodeLabels.begin();i!=nodeLabels.end();++i) {
    if(labeler->isConditionLabel(*i))
      resultSet.insert(*i);
  }
  return resultSet;
}

LabelSet CFAnalysis::functionEntryLabels(Flow& flow) {
  LabelSet resultSet;
  LabelSet nodeLabels;
  nodeLabels=flow.nodeLabels();
  for(LabelSet::iterator i=nodeLabels.begin();i!=nodeLabels.end();++i) {
    if(labeler->isFunctionEntryLabel(*i)) 
      resultSet.insert(*i);
  }
  return resultSet;
}

Label CFAnalysis::correspondingFunctionExitLabel(Label entryLabel) {
  ROSE_ASSERT(getLabeler()->isFunctionEntryLabel(entryLabel));
  SgNode* fdefnode=getNode(entryLabel);
  ROSE_ASSERT(fdefnode);
  return getLabeler()->functionExitLabel(fdefnode);
}

int CFAnalysis::numberOfFunctionParameters(Label entryLabel) {
  ROSE_ASSERT(getLabeler()->isFunctionEntryLabel(entryLabel));
  SgNode* fdefnode=getNode(entryLabel);
  ROSE_ASSERT(fdefnode);
  SgInitializedNamePtrList& params=SgNodeHelper::getFunctionDefinitionFormalParameterList(fdefnode);
  return params.size();
}

bool CFAnalysis::isVoidFunction(Label entryLabel) {
  ROSE_ASSERT(getLabeler()->isFunctionEntryLabel(entryLabel));
  SgNode* fdefnode=getNode(entryLabel);
  ROSE_ASSERT(fdefnode);
  return isSgTypeVoid(SgNodeHelper::getFunctionReturnType(fdefnode));
}

LabelSetSet CFAnalysis::functionLabelSetSets(Flow& flow) {
  LabelSetSet result;
  LabelSet feLabels=functionEntryLabels(flow);
  for(LabelSet::iterator i=feLabels.begin();i!=feLabels.end();++i) {
    Label entryLabel=*i;
    LabelSet fLabels=functionLabelSet(entryLabel, flow);
    result.insert(fLabels);
  }
  return result;
}

LabelSet CFAnalysis::functionLabelSet(Label entryLabel, Flow& flow) {
    Label exitLabel=correspondingFunctionExitLabel(entryLabel);
    LabelSet fLabels=flow.reachableNodesButNotBeyondTargetNode(entryLabel,exitLabel);
    return fLabels;
}

InterFlow CFAnalysis::interFlow(Flow& flow) {
  // 1) for each call use AST information to find its corresponding called function
  // 2) create a set of <call,entry,exit,callreturn> edges
  logger[INFO]<<"establishing inter-flow ..."<<endl;
  InterFlow interFlow;
  LabelSet callLabs=functionCallLabels(flow);
  int callLabsNum=callLabs.size();
  logger[INFO]<<"number of function call labels: "<<callLabsNum<<endl;
  int callLabNr=0;
  int externalFunCalls=0;
  int externalFunCallsWithoutDecl=0;
  int functionsFound=0;
  for(LabelSet::iterator i=callLabs.begin();i!=callLabs.end();++i) {
    //cout<<"INFO: resolving function call "<<callLabNr<<" of "<<callLabs.size()<<endl;
    SgNode* callNode=getNode(*i);
    //cout<<"INFO: Functioncall: creating inter-flow for "<<callNode->unparseToString()<<endl;
    //info: callNode->get_args()
    SgFunctionCallExp *funCall=SgNodeHelper::Pattern::matchFunctionCall(callNode);
    if(!funCall) 
      throw CodeThorn::Exception("interFlow: unknown call exp (not a SgFunctionCallExp)");
    SgFunctionDefinition* funDef=nullptr;
    switch(functionResolutionMode) {
    case FRM_TRANSLATION_UNIT: funDef=SgNodeHelper::determineFunctionDefinition(funCall);break;
    case FRM_WHOLE_AST_LOOKUP: funDef=determineFunctionDefinition2(funCall);break;
    case FRM_FUNCTION_ID_MAPPING: funDef=determineFunctionDefinition3(funCall);break;
    default:
      logger[ERROR]<<"Unsupported function resolution mode."<<endl;
      exit(1);
    }
    
    Label callLabel,entryLabel,exitLabel,callReturnLabel;
    if(funDef==0) {
      //cout<<" [no definition found]"<<endl;
      // we were not able to find the funDef in the AST
      //cout << "STATUS: External function ";
      SgFunctionDeclaration* funDecl=funCall->getAssociatedFunctionDeclaration();
      if(funDecl) {
        //cout << "External function: "<<SgNodeHelper::getFunctionName(funDecl)<<"."<<endl;
        externalFunCalls++;
      } else {
        //cout << "No function declaration found (call:"<<funCall->unparseToString()<<endl;
        externalFunCallsWithoutDecl++;
      }
      callLabel=*i;
      entryLabel=Labeler::NO_LABEL;
      exitLabel=Labeler::NO_LABEL;
      callReturnLabel=labeler->functionCallReturnLabel(callNode);
      //cout <<"No function definition found for call: "<<funCall->unparseToString()<<endl;
    } else {
      //cout<<"Found function: "<<SgNodeHelper::getFunctionName(funDef)<<endl;
      callLabel=*i;
      entryLabel=labeler->functionEntryLabel(funDef);
      exitLabel=labeler->functionExitLabel(funDef);
      callReturnLabel=labeler->functionCallReturnLabel(callNode);
      functionsFound++;
    }
    interFlow.insert(InterEdge(callLabel,entryLabel,exitLabel,callReturnLabel));
    callLabNr++;
  }
  //cout<<"STATUS: inter-flow established."<<endl;
  //cout<<"INFO: Call labels: "<<callLabNr<<endl;
  //cout<<"INFO: externalFunCalls: "<<externalFunCalls<<endl;
  //cout<<"INFO: externalFunCallWitoutDecl: "<<externalFunCallsWithoutDecl<<endl;
  //cout<<"INFO: functions found: "<<functionsFound<<endl;

  return interFlow;
}

Label CFAnalysis::getLabel(SgNode* node) {
  ROSE_ASSERT(labeler);
  return labeler->getLabel(node);
}

SgNode* CFAnalysis::getNode(Label label) {
  ROSE_ASSERT(labeler);
  return labeler->getNode(label);
}

Labeler* CFAnalysis::getLabeler() {
  return labeler;
}

// returns 0 if no statement (other than SgBasicBlock) exists in block.
SgStatement* CFAnalysis::getFirstStmtInBlock(SgBasicBlock* block) {
  ROSE_ASSERT(block);
  const SgStatementPtrList& stmtList=block->get_statements();
  if(stmtList.size()>=1) {
    return stmtList.front();
  } else {
    return 0;
  }
}

// returns 0 if no statement (other than SgBasicBlock) exists in block.
SgStatement* CFAnalysis::getLastStmtInBlock(SgBasicBlock* block) {
  ROSE_ASSERT(block);
  const SgStatementPtrList& stmtList=block->get_statements();
  if(stmtList.size()>=1) {
    return stmtList.back();
  } else {
    return 0;
  }
}

Label CFAnalysis::initialLabel(SgNode* node) {
  ROSE_ASSERT(node);

  // special case of incExpr in SgForStatement
  if(SgNodeHelper::isForIncExpr(node))
    return labeler->getLabel(node);

  // special case of function call
  if(SgNodeHelper::Pattern::matchFunctionCall(node))
    return labeler->getLabel(node);

  if(!labeler->isLabelRelevantNode(node)) {
    cerr << "Error: icfg construction: not label relevant node "<<node->sage_class_name()<<endl;
    exit(1);
  }
  ROSE_ASSERT(labeler->isLabelRelevantNode(node));
  switch (node->variantT()) {
  case V_SgFunctionDeclaration:
    cerr<<"Error: icfg construction: function declarations are not associated with a label."<<endl;
    exit(1);
  case V_SgNullStatement:
  case V_SgPragmaDeclaration:
  case V_SgLabelStatement:
    return labeler->getLabel(node);
  case V_SgFunctionDefinition:
  case V_SgBreakStmt:
  case V_SgContinueStmt:
  case V_SgReturnStmt:
  case V_SgCaseOptionStmt:
  case V_SgDefaultOptionStmt:
      return labeler->getLabel(node);

  case V_SgVariableDeclaration:
  case V_SgClassDeclaration:
  case V_SgEnumDeclaration:
      return labeler->getLabel(node);

  case V_SgExprStatement: {
    return labeler->getLabel(node);
  }
  case V_SgInitializedName:
    return labeler->getLabel(node);
  case V_SgIfStmt:
  case V_SgWhileStmt:
    node=SgNodeHelper::getCond(node);
    return labeler->getLabel(node);
  case V_SgDoWhileStmt:
    node=SgNodeHelper::getLoopBody(node);
    return labeler->getLabel(node);
  case V_SgBasicBlock:
   return labeler->blockBeginLabel(node);

   // TODO: for(emptyInitList;S;S) {}
  case V_SgForStatement: {
    SgStatementPtrList& stmtPtrList=SgNodeHelper::getForInitList(node);
    if(stmtPtrList.size()==0) {
      // empty initializer list (hence, an initialization stmt cannot be initial stmt of for)
      throw CodeThorn::Exception("Error: for-stmt: initializer-list is empty. Not supported.");
    }
    ROSE_ASSERT(stmtPtrList.size()>0);
    node=*stmtPtrList.begin();
    return labeler->getLabel(node);
  }
  case V_SgGotoStatement: {
    return labeler->getLabel(node);
  }
  case V_SgSwitchStatement: {
    node=SgNodeHelper::getCond(node);
    ROSE_ASSERT(node);
    return labeler->getLabel(node);
  }

    // all omp statements
  case V_SgOmpTargetStatement:
  case V_SgOmpParallelStatement:
  case V_SgOmpSimdStatement:
  case V_SgOmpForStatement:
  case V_SgOmpAtomicStatement:
  case V_SgOmpCriticalStatement:
  case V_SgOmpDoStatement:
  case V_SgOmpFlushStatement:	
  case V_SgOmpMasterStatement:
  case V_SgOmpOrderedStatement:
  case V_SgOmpSectionStatement:
  case V_SgOmpSectionsStatement:
  case V_SgOmpSingleStatement:
  case V_SgOmpTargetDataStatement:	
  case V_SgOmpTaskStatement:
  case V_SgOmpTaskwaitStatement:
  case V_SgOmpThreadprivateStatement:
  case V_SgOmpWorkshareStatement:
    return labeler->getLabel(node);

    // special case
  case V_SgTypedefDeclaration:
    return labeler->getLabel(node);

  case V_SgFunctionCallExp:
    // the first label of a function call is the CALL label.
    return labeler->getLabel(node);

  default:
    cerr << "Error: Unknown xnode in CodeThorn::CFAnalysis::initialLabel: "<<node->sage_class_name()<<endl;
    exit(1);
  }
}

SgStatement* CFAnalysis::getCaseOrDefaultBodyStmt(SgNode* node) {
  SgStatement* body=0;
  if(SgCaseOptionStmt* stmt=isSgCaseOptionStmt(node)) {
    body=stmt->get_body();
  } else if(SgDefaultOptionStmt* stmt=isSgDefaultOptionStmt(node)) {
    body=stmt->get_body(); 
  } else {
    cerr<<"Error: requesting body of switch case or default, but node is not a default or option stmt."<<endl;
    exit(1);
  }
  ROSE_ASSERT(body);
  return body;
} 

LabelSet CFAnalysis::finalLabels(SgNode* node) {
  ROSE_ASSERT(node);
  ROSE_ASSERT(labeler->isLabelRelevantNode(node));
  LabelSet finalSet;

  // special case of incExpr in SgForStatement
  if(SgNodeHelper::isForIncExpr(node)) {
    finalSet.insert(labeler->getLabel(node));
    return finalSet;
  }

  // special case of function call
  if(SgNodeHelper::Pattern::matchFunctionCall(node)) {
    if(SgNodeHelper::Pattern::matchReturnStmtFunctionCallExp(node)) {
      finalSet.insert(labeler->functionCallReturnLabel(node)+1); // special case of function call in return-stmt
    } else {
      finalSet.insert(labeler->functionCallReturnLabel(node));
    }
    return finalSet;
  }

  switch (node->variantT()) {
  // function declarations inside basic block
  case V_SgFunctionDeclaration:
    cerr<<"Error: icfg construction: function declarations are not associated with a label."<<endl;
    exit(1);
    //finalSet.insert(labeler->getLabel(node));
    //return finalSet;
  case V_SgFunctionDefinition: {
    SgBasicBlock* body=isSgFunctionDefinition(node)->get_body();
    return finalLabels(body);
  }
  case V_SgBreakStmt:
  case V_SgContinueStmt:
    return finalSet;
  case V_SgReturnStmt:
    return finalSet;
  case V_SgLabelStatement: {
    // MS 2/15/2018: added support for new AST structure in ROSE: SgLabelStatement(child).
    SgStatement* child=isSgLabelStatement(node)->get_statement();
    if(child) {
      LabelSet s=finalLabels(child);
      finalSet+=s;
    } else {
      finalSet.insert(labeler->getLabel(node));
    }
    return finalSet;
  }
  case V_SgNullStatement:
  case V_SgPragmaDeclaration:
  case V_SgInitializedName:
    finalSet.insert(labeler->getLabel(node));
    return finalSet;
    // declarations
  case V_SgVariableDeclaration:
  case V_SgClassDeclaration:
  case V_SgEnumDeclaration:
    finalSet.insert(labeler->getLabel(node));
    return finalSet;
  case V_SgDefaultOptionStmt:
  case V_SgCaseOptionStmt: {
    // MS 2/15/2018: added support for new AST structure in ROSE
    SgStatement* child=getCaseOrDefaultBodyStmt(node);
    if(child) {
      LabelSet s=finalLabels(child);
      finalSet+=s;
    } else {
      finalSet.insert(labeler->getLabel(node));
    }
    return finalSet;
  }
  case V_SgExprStatement: {
    finalSet.insert(labeler->getLabel(node));
    return finalSet;
  }
  case V_SgIfStmt: {
    SgNode* nodeTB=SgNodeHelper::getTrueBranch(node);
    LabelSet finalSetTB=finalLabels(nodeTB);
    finalSet+=finalSetTB;
    if(SgNode* nodeFB=SgNodeHelper::getFalseBranch(node)) {
      LabelSet finalSetFB=finalLabels(nodeFB);
      finalSet+=finalSetFB;
    } else {
      // in case of an empty else branch the cond node becomes the final node
      SgNode* condNode=SgNodeHelper::getCond(node);
      finalSet.insert(labeler->getLabel(condNode));
    }
    return finalSet;
  }
  case V_SgForStatement:
  case V_SgDoWhileStmt:
  case V_SgWhileStmt: {
    SgNode* condNode=SgNodeHelper::getCond(node);
    finalSet.insert(labeler->getLabel(condNode));
    set<SgNode*> breakNodes=SgNodeHelper::loopRelevantBreakStmtNodes(node);
    LabelSet lset=labeler->getLabelSet(breakNodes);
    finalSet+=lset;
    //cout << finalSet.toString  () << endl;
    return finalSet;
  }
  case V_SgBasicBlock: {
    if(SgNodeHelper::numChildren(node)>0) {
      SgNode* lastNode=SgNodeHelper::getLastOfBlock(node);
      LabelSet s=finalLabels(lastNode);
      finalSet+=s;
    } else {
      // empty basic block
      finalSet.insert(initialLabel(node));
    }
    return finalSet;
  }
  case V_SgFunctionCallExp:
    finalSet.insert(labeler->functionCallReturnLabel(node));
    return finalSet;
  case V_SgGotoStatement: {
    // for the goto statement (as special case) the final set is empty. This allows all other functions
    // operate correctly even in the presence of gotos. The edge for 'goto label' is created as part
    // of the semantics of goto (and does not *require* the final labels).
    return finalSet;
  }
  case V_SgSwitchStatement: {
    // 1) add all break statements, 2) add final label of last stmt (emulating a break)
    set<SgNode*> breakNodes=SgNodeHelper::loopRelevantBreakStmtNodes(node);
    LabelSet lset=labeler->getLabelSet(breakNodes);
    finalSet+=lset;
    //cout << finalSet.toString() << endl;
    // very last case in switch (not necessarily default), if it does not contain a break has still a final label.
    // if it is a break it will still be the last label. If it is a goto it will not have a final label (which is correct).
    SgSwitchStatement* switchStmt=isSgSwitchStatement(node);
    SgStatement* body=switchStmt->get_body();
    SgBasicBlock* block=isSgBasicBlock(body);
    
    // TODO: revisit, finalLabels(block) might be sufficient
    if(!block && !isSgStatement(node)) {
      cerr<<"Error: CFAnalysis::finalLabels: body of switch is not a basic block or stmt. Unknown structure."<<endl;
      exit(1);
    } else if(!block && isSgStatement(body)) {
      SgStatement* singleStmt=isSgStatement(body);
      LabelSet singleStatementLabels=finalLabels(singleStmt);
      finalSet+=singleStatementLabels;
      return finalSet;
    }

    const SgStatementPtrList& stmtList=block->get_statements();
    if(stmtList.size()>0) {
      SgNode* lastStmt=stmtList.back();
      LabelSet lsetLastStmt=finalLabels(lastStmt);
      finalSet+=lsetLastStmt;
    } else {
      cerr<<"Error: CFAnalysis::finalLabels: body of switch is empty."<<endl;
      exit(1);
    }
    return finalSet;
  }

  case V_SgOmpTargetStatement:
  case V_SgOmpParallelStatement:
  case V_SgOmpSimdStatement:
  case V_SgOmpForStatement: {
    // the final label is the final label of the child node's construct
    SgNode* nextNestedStmt=node->get_traversalSuccessorByIndex(0);
    LabelSet finalLabelSet=finalLabels(nextNestedStmt);
    finalSet+=finalLabelSet;
    return finalSet;
  }
    
    // all omp statements
  case V_SgOmpAtomicStatement:
  case V_SgOmpCriticalStatement:
  case V_SgOmpDoStatement:
  case V_SgOmpFlushStatement:	
  case V_SgOmpMasterStatement:
  case V_SgOmpOrderedStatement:
  case V_SgOmpSectionStatement:
  case V_SgOmpSectionsStatement:
  case V_SgOmpSingleStatement:
  case V_SgOmpTargetDataStatement:	
  case V_SgOmpTaskStatement:
  case V_SgOmpTaskwaitStatement:
  case V_SgOmpThreadprivateStatement:
  case V_SgOmpWorkshareStatement:
    finalSet.insert(labeler->getLabel(node));
    return finalSet;

    // special case
  case V_SgTypedefDeclaration:
    return finalSet;

  default:
    cerr << "Error: Unknown node in CFAnalysis::finalLabels: "<<node->sage_class_name()<<endl; exit(1);
  }
}


Flow CFAnalysis::flow(SgNode* s1, SgNode* s2) {
  ROSE_ASSERT(s1);
  ROSE_ASSERT(s2);
  Flow flow12;
  Flow flow1=flow(s1);
  Flow flow2=flow(s2);
  flow12+=flow1;
  flow12+=flow2;
  LabelSet finalSets1=finalLabels(s1);
  Label initLabel2=initialLabel(s2);
  for(LabelSet::iterator i=finalSets1.begin();i!=finalSets1.end();++i) {

    // special case: case-blocks of switch: an edge between case-labels never goes
    // directly from case to case, but instead to the other case's following statement (to
    // model switch-case fallthrough). The edge directly to each case label is
    // created by the CFG creation for the switch node.
    SgNode* node=getNode(initLabel2);
    if(SgCaseOptionStmt* caseStmt=isSgCaseOptionStmt(node)) {
      // adjust init label to stmt following the case label (the child of the SgCaseStmt node).
      SgNode* body=caseStmt->get_body();
      ROSE_ASSERT(body);
      initLabel2=initialLabel(body);
    } else if(SgDefaultOptionStmt* caseStmt=isSgDefaultOptionStmt(node)) {
      SgNode* body=caseStmt->get_body();
      ROSE_ASSERT(body);
      initLabel2=initialLabel(body);
    }

    Edge e(*i,initLabel2);

    // special case FALSE edges of conditions (all TRUE edges are created by the respective CFG construction)
    if(SgNodeHelper::isCond(labeler->getNode(*i))) { 
      e.addType(EDGE_FALSE);
    }
    e.addType(EDGE_FORWARD);
    flow12.insert(e);
  }
  return flow12;
}

/*! 
  * \author Markus Schordan
  * \date 2013.
 */
int CFAnalysis::inlineTrivialFunctions(Flow& flow) {
  // 1) compute all functions that are called exactly once (i.e. number of pred in ICFG is 1)
  //    AND have the number of formal parameters is 0 AND have void return type.
  // 2) inline function
  // more advanced version will also clone function-CFGs, but this makes the mapping label<->code loose the 1-1 mapping property.
  int numInlined=0;
  LabelSet lnLabs=functionEntryLabels(flow);
  for(LabelSet::iterator i=lnLabs.begin();i!=lnLabs.end();++i) {
    LabelSet pred=flow.pred(*i);
    if(pred.size()==1) {
      Label lc=*pred.begin();
      ROSE_ASSERT(getLabeler()->isFunctionCallLabel(lc));
      // check the number of formal parameters of ln
      if(numberOfFunctionParameters(*i)==0 && isVoidFunction(*i)) {

        // reduce all four nodes: lc,ln,lx,lr (this also reduces a possibly existing local edge)
        Label ln=*i;
        Label lx=correspondingFunctionExitLabel(ln);
        LabelSet succ=flow.succ(lx);
        // since we have exactly one call there must be exactly one return edge
        ROSE_ASSERT(succ.size()==1);
        Label lr=*succ.begin();
        // reduce all four nodes now
        reduceNode(flow,lc);
        reduceNode(flow,ln);
        reduceNode(flow,lx);
        reduceNode(flow,lr);
        numInlined++;
      }
    }
  }
  return numInlined;
}

int CFAnalysis::reduceEmptyConditionNodes(Flow& flow) {
  LabelSet labs=conditionLabels(flow);
  int cnt=0;
  for(LabelSet::iterator i=labs.begin();i!=labs.end();++i) {
    if(flow.succ(*i).size()==1) {
      cnt+=reduceNode(flow,*i);
    }
  }
  return cnt;
}

int CFAnalysis::reduceNode(Flow& flow, Label lab) {
  Flow inFlow=flow.inEdges(lab);
  Flow outFlow=flow.outEdges(lab);
  // edge type cleanup
  // if true and false edge exist, remove both (merging true and false branches to a single branch)
  // if forward and backward exist, remove forward (we are not removing the cycle)
  
  /* description of essential operations:
   *   inedges: (n_i,b)
   *   outedge: (b,n2) 
   *   remove(n_i,b)
   *   remove(b,n2)
   *   insert(n1,n2)
   */
  if(inFlow.size()==0 && outFlow.size()==0) {
    return 0;
  } else if(inFlow.size()>0 && outFlow.size()>0) {
    set<Edge> toErase;
    set<Edge> toInsert;
    for(Flow::iterator initer=inFlow.begin();initer!=inFlow.end();++initer) {
      for(Flow::iterator outiter=outFlow.begin();outiter!=outFlow.end();++outiter) {
        Edge e1=*initer;
        Edge e2=*outiter;
        // preserve edge annotations of ingoing and outgoing edges
        EdgeTypeSet unionEdgeTypeSet;
        EdgeTypeSet edgeTypeSet1=(*initer).types();
        unionEdgeTypeSet.insert(edgeTypeSet1.begin(),edgeTypeSet1.end());
        EdgeTypeSet edgeTypeSet2=(*outiter).types();
        // only copy an edge annotation in the outgoing edge if it is
        // not a true-annotation or a false-annotation
        for(EdgeTypeSet::iterator i=edgeTypeSet2.begin();i!=edgeTypeSet2.end();++i) {
          if(*i!=EDGE_TRUE && *i!=EDGE_FALSE) {
            unionEdgeTypeSet.insert(*i);
          }
        }
        if(unionEdgeTypeSet.find(EDGE_TRUE)!=unionEdgeTypeSet.end()
           && unionEdgeTypeSet.find(EDGE_FALSE)!=unionEdgeTypeSet.end()) {
          unionEdgeTypeSet.erase(EDGE_TRUE);
          unionEdgeTypeSet.erase(EDGE_FALSE);
        }
        if(unionEdgeTypeSet.find(EDGE_FORWARD)!=unionEdgeTypeSet.end()
           && unionEdgeTypeSet.find(EDGE_BACKWARD)!=unionEdgeTypeSet.end()) {
          unionEdgeTypeSet.erase(EDGE_FORWARD);
          // keep backward edge annotation
        }
        
        Edge newEdge=Edge(e1.source(),unionEdgeTypeSet,e2.target());
        toErase.insert(e1);
        toErase.insert(e2);
        if(e1.source()!=e2.target()) {
          toInsert.insert(newEdge);
        }
      }
    }
    for(set<Edge>::iterator i=toErase.begin();i!=toErase.end();++i) {
      flow.erase(*i);
    }
    for(set<Edge>::iterator i=toInsert.begin();i!=toInsert.end();++i) {
      flow.insert(*i);
    }
    return 1;
  } else if(inFlow.size()>0) {
    for(Flow::iterator initer=inFlow.begin();initer!=inFlow.end();++initer) {
      Edge e1=*initer;
      flow.erase(e1);
    }
    return 1;
  } else if(outFlow.size()>0) {
    for(Flow::iterator outiter=outFlow.begin();outiter!=outFlow.end();++outiter) {
      Edge e2=*outiter;
      flow.erase(e2);
    }
    return 1;
  }
  return 0;
}

int CFAnalysis::optimizeFlow(Flow& flow) {
  int n=0;
  // TODO: reduce: SgBreakStmt, SgContinueStmt, SgLabelStatement, SgGotoStatement
  n+=reduceBlockBeginNodes(flow);
  //n+=reduceEmptyConditionNodes(flow);
  return n;
}

int CFAnalysis::reduceBlockBeginEndNodes(Flow& flow) {
  int cnt=0;
  cnt+=reduceBlockBeginNodes(flow);
  cnt+=reduceBlockEndNodes(flow);
  return cnt;
}

int CFAnalysis::reduceBlockBeginNodes(Flow& flow) {
  LabelSet labs=flow.nodeLabels();
  int cnt=0;
  for(LabelSet::iterator i=labs.begin();i!=labs.end();++i) {
    if(labeler->isBlockBeginLabel(*i)) {
      cnt+=reduceNode(flow,*i);
    }
  }
  return cnt;
}

int CFAnalysis::reduceBlockEndNodes(Flow& flow) {
  LabelSet labs=flow.nodeLabels();
  int cnt=0;
  for(LabelSet::iterator i=labs.begin();i!=labs.end();++i) {
    if(labeler->isBlockEndLabel(*i)) {
      cnt+=reduceNode(flow,*i);
    }
  }
  return cnt;
}

void CFAnalysis::intraInterFlow(Flow& flow, InterFlow& interFlow) {
  for(InterFlow::iterator i=interFlow.begin();i!=interFlow.end();++i) {
    if((*i).entry==Labeler::NO_LABEL && (*i).exit==Labeler::NO_LABEL) {
#ifdef ALTERNATIVE_LOCAL_EDGE_HANDLING
      // replace local edge with external edge
      Edge localEdge=Edge((*i).call,EDGE_LOCAL,(*i).callReturn);
      Flow::iterator localEdgeIter=flow.find(localEdge);
      if(localEdgeIter!=flow.end()) {
        //cout<<"DEBUG: changing local to external edge (before): "<<(*localEdgeIter).toString()<<endl;
#if 0
        (*localEdgeIter).removeType(EDGE_LOCAL);
        (*localEdgeIter).addType(EDGE_EXTERNAL);
#else
        EdgeTypeSet tset=localEdgeIter.getTypes();
        tset.erase(EDGE_LOCAL);
        tset.insert(EDGE_EXTERNAL);
        getLabeler()->setExternalFunctionCallLabel((*i).call);
        localEdgeIter.setTypes(tset);
#endif
        //cout<<"DEBUG: changing local to external edge (after): "<<(*localEdgeIter).toString()<<endl;
        //Edge externalEdge=Edge((*i).call,EDGE_EXTERNAL,(*i).callReturn);
        //Flow::iterator externalEdgeIter=flow.find(externalEdge);
        //cout<<"DEBUG: checking external edge (after): "<<(*externalEdgeIter).toString()<<endl;
      } else {
        cerr<<"Error: did not find local edge of external call. CFG construction failed at "<<SgNodeHelper::sourceLineColumnToString(getNode((*i).call))<<endl;
      }
#else
      Edge externalEdge=Edge((*i).call,EDGE_EXTERNAL,(*i).callReturn);
      // register in Labaler as external function call
      getLabeler()->setExternalFunctionCallLabel((*i).call);
      flow.insert(externalEdge);
#endif
    } else {
      Edge callEdge=Edge((*i).call,EDGE_CALL,(*i).entry);
      flow.insert(callEdge);
      Edge callReturnEdge=Edge((*i).exit,EDGE_CALLRETURN,(*i).callReturn);
      flow.insert(callReturnEdge);

#ifdef ALTERNATIVE_LOCAL_EDGE_HANDLING
      // nothing to do. Local edges are created during intra-procedural CFG analysis.
#else
      if(_createLocalEdge) {
        Edge localEdge=Edge((*i).call,EDGE_LOCAL,(*i).callReturn);
        flow.insert(localEdge);
      }
#endif
    }
  }
}

bool CFAnalysis::isLoopConstructRootNode(SgNode* node) {
  return isSgWhileStmt(node)||isSgDoWhileStmt(node)||isSgForStatement(node);
}

// used to determine loop consttuct of  SgContinueStmt
// returns 0 if error (only possible in illformed AST)
SgNode* CFAnalysis::correspondingLoopConstruct(SgNode* node) {
  // find sourrounding loop construct (this is better implemented by
  // an init routine using an inherited attribute, but it's a very
  // short search on success (=number of nested blocks + nested branch constructs +1)
  while(!isLoopConstructRootNode(node)) {
    if(isSgFile(node))
      return 0;
    node=node->get_parent();
    if(node==0)
      return 0;
    ROSE_ASSERT(node);
  }
  ROSE_ASSERT(isLoopConstructRootNode(node));
  return node;
}

LabelSet CFAnalysis::setOfInitialLabelsOfStmtsInBlock(SgNode* node) {
  LabelSet ls;
  if(node==0)
    return ls;
  if(!isSgStatement(node)) {
    cerr<<"ERROR: "<<node->class_name()<<endl;
  }
  size_t len=node->get_numberOfTraversalSuccessors();
  for(size_t i=0;i<len;++i) {
    SgNode* childNode=node->get_traversalSuccessorByIndex(i);
    ls.insert(initialLabel(childNode));
  }
  return ls;
}

Flow CFAnalysis::controlDependenceGraph(Flow& controlFlow) {
  LabelSet condLabels=conditionLabels(controlFlow);
  LabelSet targetLabels;
  Flow controlDependenceEdges;
  for(LabelSet::iterator i=condLabels.begin();i!=condLabels.end();++i) {
    SgNode* condition=getLabeler()->getNode(*i);
    cerr<<"DEBUG: cond:"<<condition->class_name()<<endl;
    SgNode* stmt=SgNodeHelper::getParent(condition);
    cerr<<"DEBUG: stmt:"<<stmt->class_name()<<endl;
    // while/dowhile/for
    if(SgNodeHelper::isLoopCond(condition)) {
      SgNode* loopBody=SgNodeHelper::getLoopBody(stmt);
      cerr<<"DEBUG: loopBody:"<<loopBody->class_name()<<endl;
      LabelSet loopBodyInitLabels=setOfInitialLabelsOfStmtsInBlock(loopBody);
      targetLabels=loopBodyInitLabels;
    }
    // if
    if(isSgIfStmt(stmt)) {
      SgNode* trueBranch=SgNodeHelper::getTrueBranch(stmt);
      LabelSet trueBranchInitLabels=setOfInitialLabelsOfStmtsInBlock(trueBranch);
      SgNode* falseBranch=SgNodeHelper::getFalseBranch(stmt);
      LabelSet falseBranchInitLabels=setOfInitialLabelsOfStmtsInBlock(falseBranch);
      targetLabels=trueBranchInitLabels+falseBranchInitLabels;
    }
    for(LabelSet::iterator j=targetLabels.begin();j!=targetLabels.end();++j) {
      controlDependenceEdges.insert(Edge(*i,EDGE_FORWARD,*j));
    }
  }
  return controlDependenceEdges;
}

Flow CFAnalysis::WhileAndDoWhileLoopFlow(SgNode* node, 
                                         Flow edgeSet,
                                         EdgeType edgeTypeParam1,
                                         EdgeType edgeTypeParam2) {
  if(!(isSgWhileStmt(node) || isSgDoWhileStmt(node))) {
    throw CodeThorn::Exception("Error: WhileAndDoWhileLoopFlow: unsupported loop construct.");
  }
  SgNode* condNode=SgNodeHelper::getCond(node);
  Label condLabel=getLabel(condNode);
  SgNode* bodyNode=SgNodeHelper::getLoopBody(node);
  ROSE_ASSERT(bodyNode);
  Edge edge=Edge(condLabel,EDGE_TRUE,initialLabel(bodyNode));
  edge.addType(edgeTypeParam1);
  Flow flowB=flow(bodyNode);
  LabelSet finalSetB=finalLabels(bodyNode);
  edgeSet+=flowB;
  edgeSet.insert(edge);
  // back edges in while (forward edges in do-while)
  for(LabelSet::iterator i=finalSetB.begin();i!=finalSetB.end();++i) {
    Edge e;
    if(SgNodeHelper::isCond(labeler->getNode(*i))) {
      e=Edge(*i,EDGE_FALSE,condLabel);
      e.addType(edgeTypeParam2);
    } else {
      e=Edge(*i,edgeTypeParam2,condLabel);
    }
    edgeSet.insert(e);
  }
  return edgeSet;
}

LabelSet Flow::reachableNodes(Label start) {
  return reachableNodesButNotBeyondTargetNode(start,Labeler::NO_LABEL);
}

// MS: will possibly be replaced with an implementation from the BOOST graph library
LabelSet Flow::reachableNodesButNotBeyondTargetNode(Label start, Label target) {
  LabelSet reachableNodes;
  LabelSet toVisitSet=succ(start);
  size_t oldSize=0;
  size_t newSize=0;
  do {
    LabelSet newToVisitSet;
    for(LabelSet::iterator i=toVisitSet.begin();i!=toVisitSet.end();++i) {
      LabelSet succSet=succ(*i);
      for(LabelSet::iterator j=succSet.begin();j!=succSet.end();++j) {
        if(reachableNodes.find(*j)==reachableNodes.end())
          newToVisitSet.insert(*j);
      }
    }
    toVisitSet=newToVisitSet;
    oldSize=reachableNodes.size();
    reachableNodes+=toVisitSet;
    newSize=reachableNodes.size();
  } while(oldSize!=newSize);
  return reachableNodes;
}

Flow CFAnalysis::flow(SgNode* node) {
  ROSE_ASSERT(node);

  Flow edgeSet;
  if(node==0)
    return edgeSet;
  if(isSgFunctionDeclaration(node)) {
    return edgeSet;
  }

  if(isSgProject(node)||isSgFileList(node)||isSgGlobal(node)||isSgSourceFile(node)) {
    RoseAst ast(node);
    Flow tmpEdgeSet;
    // search for all functions and union flow for all functions
    for(RoseAst::iterator i=ast.begin();i!=ast.end();++i) {
      // schroder3 (2016-07-29): Added " && !isSgTemplateFunctionDefinition(*i)" to prevent
      //  SgTemplateFunctionDefinition nodes from being added to the ICFG. SgTemplateFunctionDefinitions
      //  are never called because they are only used in template declarations (SgTemplateDeclaration)
      //  (and not in template instantiation or specialization declarations (SgTemplateInstantiationFunctionDecl)).
      //  Template instantiation/ specialization declarations have "normal" SgFunctionDefinition nodes as
      //  corresponding definition. Even in case of an implicit instantiation of an implicit specialization ROSE
      //  creates a SgTemplateInstantiationFunctionDecl and copies the body of the SgTemplateFunctionDefinition
      //  to a new SgFunctionDefinition and uses the SgFunctionDefinition as definition.
      if(isSgFunctionDefinition(*i) && !isSgTemplateFunctionDefinition(*i)) {
        //cout << "STATUS: Generating flow for function "<<SgNodeHelper::getFunctionName(*i)<<endl;
        tmpEdgeSet=flow(*i);
        edgeSet+=tmpEdgeSet;
        // schroder3 (2016-07-12): We can not skip the children of a function definition
        //  because there might be a member function definition inside the function definition.
        //  Example:
        //   int main() {
        //     class A {
        //      public:
        //       void mf() {
        //         int i = 2;
        //       }
        //     };
        //   }
        //
        // MS 2018-04-05: we can skip children here, because flow does handle the body of function definitions
        i.skipChildrenOnForward();
      }
    }
    return edgeSet;
  }
  
  // special case of function call pattern
  if(SgNodeHelper::Pattern::matchFunctionCall(node)) {
#ifdef ALTERNATIVE_LOCAL_EDGE_HANDLING
    // local edge for function call: call -> callReturn is added
    Label callLabel=labeler->functionCallLabel(node);
    Label callReturnLabel=labeler->functionCallReturnLabel(node);
    edgeSet.insert(Edge(callLabel,EDGE_LOCAL,callReturnLabel));
#else
    // 'local' edge is added when intraInter flow is computed
#endif
    // add special case edge for callReturn to returnNode SgReturnStmt(SgFunctionCallExp) 
    // edge: SgFunctionCallExp.callReturn->init(SgReturnStmt)
    if(SgNodeHelper::Pattern::matchReturnStmtFunctionCallExp(node)) {
      Label callReturnLabel=labeler->functionCallReturnLabel(node);
      Label returnStmtLabel=labeler->functionCallReturnLabel(node)+1;
      edgeSet.insert(Edge(callReturnLabel,EDGE_FORWARD,returnStmtLabel));
    }
    return edgeSet;
  }

  switch (node->variantT()) {
  case V_SgFunctionDefinition: {
    
    //cout<<"Building CFG for function: "<<SgNodeHelper::getFunctionName(node)<<endl;
    SgBasicBlock* body=isSgFunctionDefinition(node)->get_body();
    Edge edge=Edge(labeler->functionEntryLabel(node),EDGE_FORWARD,initialLabel(body));
    edgeSet.insert(edge);
    Flow bodyFlow=flow(body);
    edgeSet+=bodyFlow;
    /* add explicitly edge from last stmt of function to exit-node
       not that a return at the end of a function is *not* represented in a ROSE AST.
       if return does not exist, we need to add an explicit edge from end of function to exit
       since we create this edge with the computed final node a branch with returns in all branches is
       maintained properly.
       this edge is identical if we have some other branches. Because we maintain the edges as an edge-set
       this operation is always OK.
     */
#if 0
    LabelSet funFinalLabels=finalLabels(node);
#else
    LabelSet funFinalLabels=finalLabels(body);
#endif
    for(LabelSet::iterator i=funFinalLabels.begin();i!=funFinalLabels.end();++i) {
      Edge explicitEdge=Edge(*i,EDGE_FORWARD,labeler->functionExitLabel(node));
      if(SgNodeHelper::isLoopCond(labeler->getNode(*i))) {
        explicitEdge.addType(EDGE_FALSE);
      }
      if(SgNodeHelper::isCond(labeler->getNode(*i))) {
        if(SgIfStmt* ifStmt=isSgIfStmt(labeler->getNode(*i)->get_parent())) {
          if(!SgNodeHelper::getFalseBranch(ifStmt)) {
            // MS: 07/02/2014: in case of empty if-false branch (at end of function), FALSE must be added to explicit node (only if-false can be empty)
            explicitEdge.addType(EDGE_FALSE);
          }
        }
      }
      edgeSet.insert(explicitEdge);
    }
    return edgeSet;
  }
  case V_SgReturnStmt: {
    SgNode* funcDef=SgNodeHelper::correspondingSgFunctionDefinition(node);
    if(!funcDef)
      cerr << "Error: No corresponding function for ReturnStmt found."<<endl;
    ROSE_ASSERT(isSgFunctionDefinition(funcDef));
    Edge edge=Edge(getLabel(node),EDGE_FORWARD,labeler->functionExitLabel(funcDef));
    edgeSet.insert(edge);
    return edgeSet;
  }
  case V_SgLabelStatement: {
    // MS 2/15/2018: added support for new AST structure in ROSE: SgLabelStatement(child).
    SgStatement* child=isSgLabelStatement(node)->get_statement();
    if(child) {
      Edge edge=Edge(getLabel(node),EDGE_FORWARD,initialLabel(child));
      edgeSet.insert(edge);
      Flow flowSgLabelChild=flow(child);
      edgeSet+=flowSgLabelChild;
    }
    return edgeSet;
  }
  case V_SgBreakStmt:
  case V_SgInitializedName:
  case V_SgNullStatement:
  case V_SgPragmaDeclaration:
  case V_SgExprStatement:
    return edgeSet;

    // declarations
  case V_SgVariableDeclaration:
  case V_SgClassDeclaration:
  case V_SgEnumDeclaration:
    return edgeSet;

    // parallel nested omp constructs
  case V_SgOmpTargetStatement:
  case V_SgOmpParallelStatement:
  case V_SgOmpSimdStatement:
  case V_SgOmpForStatement: {
    SgNode* nextNestedStmt=node->get_traversalSuccessorByIndex(0);
    // need to compute flow of next stmt because it is nested (and not at basic-block level)
    Flow nextNestedStmtFlow=flow(nextNestedStmt);
    edgeSet+=nextNestedStmtFlow;

    // the label is the final label (but function finalLabels cannot be used here because it gives the final labels of the entire nested construct)
    Label lab=getLabel(node);
    Edge edge1=Edge(lab,EDGE_FORWARD,initialLabel(nextNestedStmt));
    edgeSet.insert(edge1);
    return edgeSet;
  }
    // these omp statements do not generate edges in addition to the ingoing and outgoing edge
  case V_SgOmpAtomicStatement:
  case V_SgOmpCriticalStatement:
  case V_SgOmpDoStatement:
  case V_SgOmpFlushStatement:	
  case V_SgOmpMasterStatement:
  case V_SgOmpOrderedStatement:
  case V_SgOmpSectionStatement:
  case V_SgOmpSectionsStatement:
  case V_SgOmpSingleStatement:
  case V_SgOmpTargetDataStatement:	
  case V_SgOmpTaskStatement:
  case V_SgOmpTaskwaitStatement:
  case V_SgOmpThreadprivateStatement:
  case V_SgOmpWorkshareStatement:
    return edgeSet;

    // special case
  case V_SgTypedefDeclaration:
    return edgeSet;

  case V_SgContinueStmt: {
    SgNode* loopStmt=correspondingLoopConstruct(node);
    if(isSgWhileStmt(loopStmt)) {
      // target is condition node
      SgNode* targetNode=SgNodeHelper::getCond(loopStmt);
      ROSE_ASSERT(targetNode);
      Edge edge=Edge(getLabel(node),EDGE_BACKWARD,getLabel(targetNode));
      edgeSet.insert(edge);
    } else if(isSgDoWhileStmt(loopStmt)) {
      // target is condition node
      SgNode* targetNode=SgNodeHelper::getCond(loopStmt);
      ROSE_ASSERT(targetNode);
      Edge edge=Edge(getLabel(node),EDGE_FORWARD,getLabel(targetNode));
      edgeSet.insert(edge);
    } else if(isSgForStatement(loopStmt)) {
      // target is increment expr
      SgExpression* incExp=SgNodeHelper::getForIncExpr(loopStmt);
      if(!incExp)
        throw CodeThorn::Exception("CFAnalysis: for-loop: empty incExpr not supported.");
      SgNode* targetNode=incExp;
      ROSE_ASSERT(targetNode);
      Edge edge=Edge(getLabel(node),EDGE_FORWARD,getLabel(targetNode));
      edgeSet.insert(edge);
    } else {
      throw CodeThorn::Exception("CFAnalysis: continue in unknown loop construct (not while,do-while, or for).");
    }
    return edgeSet;
  }
  case V_SgIfStmt: {
    SgNode* nodeC=SgNodeHelper::getCond(node);
    Label condLabel=getLabel(nodeC);
    SgNode* nodeTB=SgNodeHelper::getTrueBranch(node);
    Edge edgeTB=Edge(condLabel,EDGE_TRUE,initialLabel(nodeTB));
    edgeTB.addType(EDGE_FORWARD);
    edgeSet.insert(edgeTB);
    Flow flowTB=flow(nodeTB);
    edgeSet+=flowTB;
    if(SgNode* nodeFB=SgNodeHelper::getFalseBranch(node)) {
      Flow flowFB=flow(nodeFB);
      Edge edgeFB=Edge(condLabel,EDGE_FALSE,initialLabel(nodeFB));
      edgeFB.addType(EDGE_FORWARD);
      edgeSet.insert(edgeFB);
      edgeSet+=flowFB;
    }
    return edgeSet;
  }
  case V_SgGotoStatement: {
    SgGotoStatement* gotoStmt=isSgGotoStatement(node);
    SgLabelStatement* targetSgLabelStmt=gotoStmt->get_label();
    ROSE_ASSERT(targetSgLabelStmt);
    // note that the target label is not an element of the finalLabels set.
    Label targetLabel=labeler->getLabel(targetSgLabelStmt);
    edgeSet.insert(Edge(initialLabel(node),EDGE_FORWARD,targetLabel));
    return edgeSet;
  }

  case V_SgCaseOptionStmt:
  case V_SgDefaultOptionStmt: {
    Label caseStmtLab=labeler->getLabel(node);
    SgStatement* caseBody=getCaseOrDefaultBodyStmt(node);
    if(caseBody) {
      edgeSet.insert(Edge(caseStmtLab,EDGE_FORWARD,initialLabel(caseBody)));
      Flow flowStmt=flow(caseBody);
      edgeSet+=flowStmt;
    } else {
      // single case/default without body: no edges inside this construct, intentionally empty.
    }
    return edgeSet;
    break;
  }
  case V_SgSwitchStatement: {
    // create edges for body of switch
    SgSwitchStatement* switchStmt=isSgSwitchStatement(node);
    SgStatement* block=switchStmt->get_body();
    Flow blockFlow=flow(block);
    edgeSet+=blockFlow;
    // create edges from condition to case (if they exist)
    SgNode* nodeC=SgNodeHelper::getCond(node);
    Label condLabel=getLabel(nodeC);
    std::set<SgCaseOptionStmt*> caseNodes=SgNodeHelper::switchRelevantCaseStmtNodes(block);
    for (auto caseNode : caseNodes) {
      edgeSet.insert(Edge(condLabel,EDGE_FORWARD,initialLabel(caseNode)));
    }
    // create edge from condition to default label (if it exists)
    SgDefaultOptionStmt* defaultNode=SgNodeHelper::switchRelevantDefaultStmtNode(block);
    if(defaultNode) {
      edgeSet.insert(Edge(condLabel,EDGE_FORWARD,initialLabel(defaultNode)));
    }
    // special case: if there are no case and no default labels, create an edge to the block or stmt
    if(caseNodes.size()==0 && !defaultNode) {
      edgeSet.insert(Edge(condLabel,EDGE_FORWARD,initialLabel(block)));
    }
    return edgeSet;
  }
  case V_SgWhileStmt: 
    return WhileAndDoWhileLoopFlow(node,edgeSet,EDGE_FORWARD,EDGE_BACKWARD);
  case V_SgDoWhileStmt: 
    return WhileAndDoWhileLoopFlow(node,edgeSet,EDGE_BACKWARD,EDGE_FORWARD);
  case V_SgBasicBlock: {
    size_t len=node->get_numberOfTraversalSuccessors();
    if(len==0) {
      return edgeSet;
    } else {
      if(len==1) {
        SgNode* onlyStmt=node->get_traversalSuccessorByIndex(0);
        Flow onlyFlow=flow(onlyStmt);
        edgeSet+=onlyFlow;
      } else {
        for(size_t i=0;i<len-1;++i) {
          SgNode* childNode1=node->get_traversalSuccessorByIndex(i);
          SgNode* childNode2=node->get_traversalSuccessorByIndex(i+1);
          Flow flow12=flow(childNode1,childNode2);
          edgeSet+=flow12;
        }
      }
    }
    SgNode* firstStmt=node->get_traversalSuccessorByIndex(0);
    Edge edge1=Edge(labeler->blockBeginLabel(node),EDGE_FORWARD,initialLabel(firstStmt));
    edgeSet.insert(edge1);
    ROSE_ASSERT(len>=1);
    // do not generate edges to blockEndLabel
#if 0
    SgNode* lastStmt=node->get_traversalSuccessorByIndex(len-1);
    ROSE_ASSERT(isSgStatement(lastStmt));
    LabelSet lastStmtFinalLabels=finalLabels(lastStmt);
    for(LabelSet::iterator i=lastStmtFinalLabels.begin();i!=lastStmtFinalLabels.end();++i) {
      Edge edge2=Edge(*i,EDGE_FORWARD,labeler->blockEndLabel(node));
      edgeSet.insert(edge2);
    }
#endif
    return edgeSet;
  }

  case V_SgForStatement: {
    SgStatementPtrList& stmtPtrList=SgNodeHelper::getForInitList(node);
    int len=stmtPtrList.size();
    if(len==0) {
      // empty initializer list (hence, an initialization stmt cannot be initial stmt of for)
      cout << "INFO: for-stmt: initializer-list is empty."<<endl;
      cerr << "Error: empty for-stmt initializer (should be an empty statement node)."<<endl;
      exit(1);
    }
    ROSE_ASSERT(len>0);
    SgNode* lastNode=0;
    if(len==1) {
      SgNode* onlyStmt=*stmtPtrList.begin();
      Flow onlyFlow=flow(onlyStmt);
      edgeSet+=onlyFlow;
      lastNode=onlyStmt;
    } else {
      ROSE_ASSERT(stmtPtrList.size()>=2);
      for(SgStatementPtrList::iterator i=stmtPtrList.begin();
          i!=stmtPtrList.end();
          ++i) {
        SgNode* node1=*i;
        SgStatementPtrList::iterator i2=i;
        i2++;
        SgNode* node2=*i2;
        Flow flow12=flow(node1,node2);
        edgeSet+=flow12;
        i2++;
        if(i2==stmtPtrList.end()) {
          lastNode=node2;
          break;
        }        
      }
    }
    SgNode* condNode=SgNodeHelper::getCond(node);
    if(!condNode)
      throw CodeThorn::Exception("Error: for-loop: empty condition not supported. Normalization required.");
    Flow flowInitToCond=flow(lastNode,condNode);
    edgeSet+=flowInitToCond;
    Label condLabel=getLabel(condNode);
    SgNode* bodyNode=SgNodeHelper::getLoopBody(node);
    ROSE_ASSERT(bodyNode);
    Edge edge=Edge(condLabel,EDGE_TRUE,initialLabel(bodyNode));
    edge.addType(EDGE_FORWARD);
    Flow flowB=flow(bodyNode);
    edgeSet+=flowB;
    edgeSet.insert(edge);

    // Increment Expression:
    SgExpression* incExp=SgNodeHelper::getForIncExpr(node);
    if(!incExp)
      throw CodeThorn::Exception("Error: for-loop: empty incExpr not supported. Normalization required.");
    ROSE_ASSERT(incExp);
    Label incExpLabel=getLabel(incExp);
    ROSE_ASSERT(incExpLabel!=Labeler::NO_LABEL);

    // Edges from final labels of for body to the increment expression:
    LabelSet finalSetB=finalLabels(bodyNode);
    for(LabelSet::iterator i=finalSetB.begin();i!=finalSetB.end();++i) {
      Edge edgeToIncExpr=Edge(*i,EDGE_FORWARD,incExpLabel);
      if(SgNodeHelper::isCond(labeler->getNode(*i))) {
        edgeToIncExpr.addType(EDGE_FALSE);
      }
      edgeSet.insert(edgeToIncExpr);
    }

    // Edge from increment expression back to condition:
    Edge backwardEdge = Edge(incExpLabel,EDGE_BACKWARD,condLabel);
    edgeSet.insert(backwardEdge);
    return edgeSet;
  }
  default:
    throw CodeThorn::Exception("Unknown node in CFAnalysis::flow: Problemnode "+node->class_name()+" Input file: "+SgNodeHelper::sourceLineColumnToString(node)+": "+node->unparseToString());
  }
}

// slow lookup
SgFunctionDefinition* CFAnalysis::determineFunctionDefinition2(SgFunctionCallExp* funCall) {
  if(SgFunctionDeclaration* funDecl=funCall->getAssociatedFunctionDeclaration()) {
    if(SgDeclarationStatement* defFunDecl=funDecl->get_definingDeclaration()) {
      if(SgFunctionDeclaration* funDecl2=isSgFunctionDeclaration(defFunDecl)) {
        if(SgFunctionDefinition* funDef=funDecl2->get_definition()) {
          return funDef;
        } else {
          //cout<<"INFO: no definition found for call: "<<funCall->unparseToString()<<endl;
          //return 0;
          // the following code is dead code: searching the AST is inefficient. This code will refactored and removed from here.
          // forward declaration (we have not found the function definition yet)
          // 1) use parent pointers and search for Root node (likely to be SgProject node)
          SgNode* root=defFunDecl;
          SgNode* parent=0;
          while(!SgNodeHelper::isAstRoot(root)) {
            parent=SgNodeHelper::getParent(root);
            root=parent;
          }
          ROSE_ASSERT(root);
          // 2) search in AST for the function's definition now
          RoseAst ast(root);
          for(RoseAst::iterator i=ast.begin();i!=ast.end();++i) {
            if(SgFunctionDeclaration* funDecl2=isSgFunctionDeclaration(*i)) {
              if(!SgNodeHelper::isForwardFunctionDeclaration(funDecl2)) {
                SgSymbol* sym2=funDecl2->search_for_symbol_from_symbol_table();
                SgSymbol* sym1=funDecl->search_for_symbol_from_symbol_table();
                if(sym1!=0 && sym1==sym2) {
                  SgFunctionDefinition* fundef2=funDecl2->get_definition();
                  ROSE_ASSERT(fundef2);
                  return fundef2;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

SgFunctionDefinition* CFAnalysis::determineFunctionDefinition3(SgFunctionCallExp* funCall) {
  SgFunctionDefinition* funDef=nullptr;
  // TODO (use function id mapping)
  logger[ERROR]<<"CFAnalysis::determineFunctionDefinition3 not implemented."<<endl;
  exit(1);
  return funDef;
}
