%{
#include <stdio.h>
#include <string.h>

#include "crsh.hpp"

void yyerror(const char *str)
{
  fprintf(stderr,"error: %s\n",str);
}

int yywrap()
{
  return 1;
}

int yylex();

%}

%error-verbose

%union {
  int                 m_num;
  char*               m_str;
  Crsh::EnvValue*     m_env;
  Environment*        m_environment;
  std::string*        m_arg;
  Arguments*          m_arguments;
  InvocationDesc*     m_invoke;
  Crsh::expectation   m_success;
}

%token CONNECT
%token EQUAL
%token EXIT
%token EXPECT
%token EXPORT
%token LBLK
%token RBLK
%token RUN
%token ECHO
%token QUAL
%token <m_str> QUOTSTR
%token SPECIMEN
%token <m_num> NUM
%token <m_str> SQLLITE
%token <m_str> STRING
%token VAR

%type <m_num>         num num_opt
%type <m_str>         filename ident string specimen testsuite_opt
%type <m_str>         simple_string quoted_string
%type <m_env>         export
%type <m_environment> environ_opt
%type <m_arg>         argument
%type <m_arguments>   arguments_opt
%type <m_invoke>      test_invoke
%type <m_success>     fail_opt fail_note

%start crush

%%
num              : NUM                       { $$ = $1; }
                 ;

filename         : SQLLITE                   { $$ = $1; }
                 ;

ident            : STRING                    { $$ = $1; }
                 ;

simple_string    : STRING                    { $$ = $1; }
                 ;

quoted_string    : QUOTSTR                   { $$ = crsh().unquote_string($1); }
                 ;

string           : simple_string             { $$ = $1; }
                 | quoted_string             { $$ = $1; }
                 ;

export           : EXPORT ident EQUAL string { $$ = crsh().envvar($2, $4); }

environ_opt      : /* empty */               { $$ = crsh().environment();       }
                 | environ_opt export        { $$ = crsh().environment($1, $2); }
                 ;

argument         : string                    { $$ = crsh().arg($1); }
                 ;

arguments_opt    : /* empty */               { $$ = crsh().args();       }
                 | arguments_opt argument    { $$ = crsh().args($1, $2); }
                 ;

specimen         : string                    { $$ = $1; }
                 ;

fail_note        : EXPECT string             { $$ = crsh().annotate($2); }

fail_opt         : /* empty */               { $$ = Crsh::none;    }
                 | fail_note                 { $$ = $1; }
                 ;

test_invoke      : specimen arguments_opt    { $$ = crsh().invoke($1, $2); }
                 ;

test_cmd         : ident QUAL ident
                   fail_opt
                   LBLK
                     environ_opt
                     test_invoke
                   RBLK                      { crsh().test($1, $3, $4, $6, $7); }
                 ;

testsuite_opt    : /* empty */               { $$ = NULL; }
                 | ident QUAL                { $$ = $1; }
                 ;

num_opt          : /* empty */               { $$ = -1; }
                 | num                       { $$ = $1; }
                 ;

exec_cmd         : testsuite_opt
                   RUN num_opt fail_opt      { crsh().run($1, $3, $4); }
                 ;

connect_cmd      : CONNECT filename          { crsh().connect($2); }
                 ;

echo_cmd         : ECHO string               { crsh().echo($2); }
                 | ECHO VAR ident            { crsh().echo_var($3); }
                 ;

exit_cmd         : EXIT
                 ;

cmd              : test_cmd
                 | exec_cmd
                 | connect_cmd
                 | echo_cmd
                 | exit_cmd
                 ;

cmds_opt         : /* empty */
                 | cmd cmds_opt
                 ;

crush            : cmds_opt
                 ;
